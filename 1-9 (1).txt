def listToString(list1):
    str = ""
    str1=''
    for e in list1:
        str1 += e
    return str1
def ceaser_cipher_E(key,text):
    k=key
    p=text
    l=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    c=list(p)
    for i in range(0,len(p)):
        for j in range(0,len(l)):
            if(p[i]==l[j]):
                p1=j
        c1=(p1+k)%26
        c[i]=l[c1]
    
    return listToString(c)

def ceaser_cipher_D(key,text):
    k=key
    c=text
    l=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    d=list(c)
    for i in range(0,len(c)):
        for j in range(0,len(l)):
            if(c[i]==l[j]):
                c1=j
        d1=(c1-k)%26
        d[i]=l[d1]
    return listToString(d)

text = str(input("Enter a Text:"))
key = int(input("Enter a key:"))
print("The Encrypted text is ",ceaser_cipher_E(key,text))
print("The Decrypted Text is " ,ceaser_cipher_D(key,ceaser_cipher_E(key,text)))

--------------------------------------------------------------------------------------------------
def list_to_string(l):
    string=''
    for i in range(0,len(l)):
        string+=l[i]
    return string
    
def monoalphabetic_cipher_en(text,key): #key="a to z in any format"

    list1=list("abcdefghijklmnopqrstuvwxyz")
    key1=list(key)
    
    dict1={}
    
    for i in range(0,len(list1)):
        for j in range(0,len(key1)):
            if(i==j):
                dict1[list1[i]]=key1[j]

    text1=list(text)
    en_list=[]
    dict2 = {}
    for n in text1:
        for d in dict1:
            if(n == d):
                en_list.append(dict1[d])

    
                
    return list_to_string(en_list)   

def monoalphabetic_cipher_de(ciphertext, key):
    list1 = list("abcdefghijklmnopqrstuvwxyz")
    key1 = list(key)

    dict1 = {}

    for i in range(0, len(list1)):
        for j in range(0, len(key1)):
            if i == j:
                dict1[key1[j]] = list1[i]

    ciphertext1 = list(ciphertext)
    de_list = []
    dict2 = {}
    for n in ciphertext1:
        for d in dict1:
            if n == d:
                de_list.append(dict1[d])

    return list_to_string(de_list)



text = input("Enter a text: ")
key = input("Enter monoalphabetic cipher key: ")

encrypted_text = monoalphabetic_cipher_en(text, key)
print("The encrypted text is:", encrypted_text)

decrypted_text = monoalphabetic_cipher_de(encrypted_text, key)
print("The decrypted text is:", decrypted_text)

-----------------------------------
---------------------------------- pr2
def prepare_text(text):
    # Remove spaces and convert to uppercase
    text = text.replace(" ", "").upper()
    # Replace 'J' with 'I'
    text = text.replace("J", "I")
    # Split the text into pairs of two characters
    text_pairs = [text[i:i+2] for i in range(0, len(text), 2)]

    # Add 'X' at the end if the text length is odd
    if len(text) % 2 != 0:
        text_pairs[-1] += 'X'

    return text_pairs

def create_playfair_matrix(key):
    key = key.replace(" ", "").upper()
    key = key.replace("J", "I")
    alphabet = "ABCDEFGHIKLMNOPQRSTUVWXYZ"
    matrix = []

    for char in key + alphabet:
        if char not in matrix:
            matrix.append(char)

    playfair_matrix = [matrix[i:i+5] for i in range(0, 25, 5)]
    return playfair_matrix

def find_position(matrix, char):
    for i in range(5):
        for j in range(5):
            if matrix[i][j] == char:
                return i, j

def playfair_encrypt(text, key):
    text_pairs = prepare_text(text)
    playfair_matrix = create_playfair_matrix(key)
    encrypted_text = []

    for pair in text_pairs:
        char1, char2 = pair
        row1, col1 = find_position(playfair_matrix, char1)
        row2, col2 = find_position(playfair_matrix, char2)

        if row1 == row2:
            encrypted_char1 = playfair_matrix[row1][(col1 + 1) % 5]
            encrypted_char2 = playfair_matrix[row2][(col2 + 1) % 5]
        elif col1 == col2:
            encrypted_char1 = playfair_matrix[(row1 + 1) % 5][col1]
            encrypted_char2 = playfair_matrix[(row2 + 1) % 5][col2]
        else:
            encrypted_char1 = playfair_matrix[row1][col2]
            encrypted_char2 = playfair_matrix[row2][col1]

        encrypted_text.append(encrypted_char1 + encrypted_char2)

    return "".join(encrypted_text)

def playfair_decrypt(ciphertext, key):
    playfair_matrix = create_playfair_matrix(key)
    decrypted_text = []

    for pair in prepare_text(ciphertext):
        char1, char2 = pair
        row1, col1 = find_position(playfair_matrix, char1)
        row2, col2 = find_position(playfair_matrix, char2)

        if row1 == row2:
            decrypted_char1 = playfair_matrix[row1][(col1 - 1) % 5]
            decrypted_char2 = playfair_matrix[row2][(col2 - 1) % 5]
        elif col1 == col2:
            decrypted_char1 = playfair_matrix[(row1 - 1) % 5][col1]
            decrypted_char2 = playfair_matrix[(row2 - 1) % 5][col2]
        else:
            decrypted_char1 = playfair_matrix[row1][col2]
            decrypted_char2 = playfair_matrix[row2][col1]

        decrypted_text.append(decrypted_char1 + decrypted_char2)

    return "".join(decrypted_text)

# Example usage:
key = "KEYWORD"
plaintext = "HELLO"
encrypted_text = playfair_encrypt(plaintext, key)
print("Encrypted:", encrypted_text)
decrypted_text = playfair_decrypt(encrypted_text, key)
print("Decrypted:", decrypted_text)
---------------------------------------------------------------------------------------------------------------

l = "abcdefghijklmnopqrstuvwxyz"
pt = input("Enter plain text: ").replace(" ", "")
lenk = int(input("Enter length of key: "))
k = []

for i in range(0, lenk):
    v = int(input("Enter key" + str(i + 1) + ":"))
    k.append(v)

en = ""
de = ""
n = 0

for i in range(0, len(pt)):
    if n < len(k):
        n = n + 1
    if n >= len(k):
        n = 0
    ind = (l.index(pt[i]) + k[n - 1]) % 26
    en = en + l[ind]

n = 0

print("\nEncrypted text: ", en)

for i in range(0, len(pt)):
    if n < len(k):
        n = n + 1
    if n >= len(k):
        n = 0
    ind = (l.index(en[i]) - k[n - 1]) % 26
    de = de + l[ind]

print("\nDecrypted text: ", de)
-----------------------------------------------------------------------------------------------------------
def vernam_encrypt(pt, key):
    alpha = "abcdefghijklmnopqrstuvwxyz"
    pt = pt.replace(" ", "")
    en = ""

    for i in range(len(key)):
        c = alpha.index(pt[i]) ^ alpha.index(key[i])
        en += alpha[c % 26]

    return en

def vernam_decrypt(ct, key):
    alpha = "abcdefghijklmnopqrstuvwxyz"
    de = ""

    for i in range(len(key)):
        c = alpha.index(ct[i]) ^ alpha.index(key[i])
        if c > 20:
            de += alpha[abs(c - 26) % 26]
        else:
            de += alpha[c % 26]

    return de

pt = input("Enter Plain Text: ")
key = input("Enter Key: ")

if len(pt) == len(key):
    ct = vernam_encrypt(pt, key)
    print("Encrypted Text:", ct)

    de = vernam_decrypt(ct, key)
    print("Decrypted Text:", de)
else:
    print("Key should be of the same length as the plaintext.")
----------------------------------------
----------------------------------------------pr3
def encryptRailFence(text, key):
    rail = [['\n' for i in range(len(text))] for j in range(key)]
    dir_down = False
    row, col = 0, 0

    for i in range(len(text)):
        if row == 0 or row == key - 1:
            dir_down = not dir_down
        rail[row][col] = text[i]
        col += 1
        if dir_down:
            row += 1
        else:
            row -= 1

    result = []
    for i in range(key):
        for j in range(len(text)):
            if rail[i][j] != '\n':
                result.append(rail[i][j])
    return "".join(result)

def decryptRailFence(cipher, key):
    rail = [['\n' for i in range(len(cipher))] for j in range(key)]
    dir_down = None
    row, col = 0, 0

    for i in range(len(cipher)):
        if row == 0:
            dir_down = True
        if row == key - 1:
            dir_down = False
        rail[row][col] = '*'
        col += 1
        if dir_down:
            row += 1
        else:
            row -= 1

    index = 0
    for i in range(key):
        for j in range(len(cipher)):
            if rail[i][j] == '*' and index < len(cipher):
                rail[i][j] = cipher[index]
                index += 1

    result = []
    row, col = 0, 0
    for i in range(len(cipher)):
        if row == 0:
            dir_down = True
        if row == key - 1:
            dir_down = False
        if rail[row][col] != '*':
            result.append(rail[row][col])
        col += 1
        if dir_down:
            row += 1
        else:
            row -= 1

    return "".join(result)

if __name__ == "__main__":
    encrypted_text = encryptRailFence("hello world", 2)
    print("Encrypted:", encrypted_text)
    
    decrypted_text = decryptRailFence(encrypted_text, 2)
    print("Decrypted:", decrypted_text)
-----------------------------------------------------------------------------------
import math

key = "HACK"

def encryptMessage(msg):
    cipher = ""
    k_indx = 0

    msg_len = float(len(msg))
    msg_lst = list(msg)
    key_lst = sorted(list(key))
    col = len(key)
    row = int(math.ceil(msg_len / col))
    fill_null = int((row * col) - msg_len)
    msg_lst.extend('_' * fill_null)
    matrix = [msg_lst[i: i + col] for i in range(0, len(msg_lst), col)]

    for _ in range(col):
        curr_idx = key.index(key_lst[k_indx])
        cipher += ''.join([row[curr_idx] for row in matrix])
        k_indx += 1

    return cipher

def decryptMessage(cipher):
    msg = ""
    k_indx = 0
    msg_indx = 0
    msg_len = float(len(cipher))
    msg_lst = list(cipher)
    col = len(key)
    row = int(math.ceil(msg_len / col))
    key_lst = sorted(list(key))
    dec_cipher = []

    for _ in range(row):
        dec_cipher += [[None] * col]

    for _ in range(col):
        curr_idx = key.index(key_lst[k_indx])
        for j in range(row):
            dec_cipher[j][curr_idx] = msg_lst[msg_indx]
            msg_indx += 1
        k_indx += 1

    try:
        msg = ''.join(sum(dec_cipher, []))
    except TypeError:
        raise TypeError("This program cannot handle repeating words.")

    null_count = msg.count('_')
    if null_count > 0:
        return msg[:-null_count]
    return msg

# Driver Code
msg = input("Enter Message: ")
cipher = encryptMessage(msg)
print("Encrypted Message:", cipher)
print("Decrypted Message:", decryptMessage(cipher))

--------------------------------------
----------------------------------pr4
from des import DesKey 
pt= bytes(input("enter plain Text :") ,'utf-8') 
key=bytes(input("enter Key :") ,'utf-8') 
k= DesKey(key) 
k.is_single() 
en=k.encrypt(pt) 
print("Encrypted Text :") 
print(en) 
de=k.decrypt(en) 
print("Decrypted Text :") 
print(de)

-------------------------------------------
import aes
pt = input("Enter plain Text: ").encode('utf-8')
masterkey = input("Enter Key: ").encode('utf-8')

# Convert masterkey from bytes to integer
masterkey = int.from_bytes(masterkey, byteorder='big')
pt = int.from_bytes(pt, byteorder='big')

cipher = aes.aes(masterkey, 128)

ct = cipher.enc_once(pt)

print("ct =", ct)
print("Encrypted text is", hex(aes.utils.arr8bit2int(ct))[2:].zfill(32))

pr = cipher.dec_once(ct)
print("pr =", pr)
print("Decrypted text is", hex(aes.utils.arr8bit2int(pr))[2:].zfill(32))
----------------------------------------------------------
from arc4 import ARC4

pt = bytes(input("Enter plain Text: "), 'utf-8')
key = bytes(input("Enter Key: "), 'utf-8')

arc4 = ARC4(key)
cipher = arc4.encrypt(pt)

print("Encrypted text: ", cipher)

# Decryption
decipher = arc4.decrypt(cipher)

print("Decrypted text: ", decrypted_text)
-------------------------------------
-------------------------------------pr5
import pyDH

d1 = pyDH.DiffieHellman()
d2 = pyDH.DiffieHellman()

d1_pubkey = d1.gen_public_key()
d2_pubkey = d2.gen_public_key()
print("public key 1:",d1_pubkey)
print("public key 2:",d2_pubkey)

d1_sharedkey = d1.gen_shared_key(d2_pubkey)
d2_sharedkey = d2.gen_shared_key(d1_pubkey)

if(d1_sharedkey == d2_sharedkey):
    print("The shared key is ",d1_sharedkey)
else:
    print("The sharedkeys are different")

------------------------------------------------------

#Diffie hellman key exchange
from math import sqrt
# Returns True if n is prime
def isPrime( n):
	if (n <= 1):
		return False
	if (n <= 3):
		return True
	if (n % 2 == 0 or n % 3 == 0):
		return False
	i = 5
	while(i * i <= n):
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6
	return True

def power( x, y, p):
	res = 1 # Initialize result
	x = x % p # Update x if it is more than or equal to p
	while (y > 0):
		# If y is odd, multiply x with result
		if (y & 1):
			res = (res * x) % p
			# y must be even now
			y = y >> 1 # y = y/2
			x = (x * x) % p
	return res
# Utility function to store prime factors of a number
def findPrimefactors(s, n) :
	# Print the number of 2s that divide n
	while (n % 2 == 0) :
		s.add(2)
		n = n // 2
		# n must be odd at this po. So we can
		# skip one element (Note i = i +2)
	for i in range(3, int(sqrt(n)), 2):
		# While i divides n, print i and divide n
		while (n % i == 0) :
			s.add(i)
			n = n // i
	# This condition is to handle the case
	# when n is a prime number greater than 2
	if (n > 2) :
		s.add(n)
# Function to find smallest primitive root of n
def findPrimitive( n) :
	s = set()
	# Check if n is prime or not
	if (isPrime(n) == False):
		return -1
	phi = n - 1
	#findPrimefactors(s, phi)
	for r in range(2, phi + 1):
		flag = False
		for it in s:
			if (power(r, phi // it, n) == 1):
				flag = True
				break
		if (flag == False):
			return r
	return r
#generating public key of user A,B
def pua(xa,a,q):
	if xa<q:
		ya=(a**xa) % q
		return ya
	else:
		print("xa should be < ", q)
		#key generation
def keyGen(x,y,q):
	k=(y**x) % q
	return k
q = int(input("Enter prime number:"))
a=findPrimitive(q)
xa=int(input("Enter private key of user A (<q) : "))
xb=int(input("Enter private key of user B (<q) : "))
ya=pua(xa,a,q)
yb=pua(xb,a,q)
ka=keyGen(xa,yb,q)
kb=keyGen(xb,ya,q)
print("Smallest primitive root of",q, "is", a)
print("ya=",ya)
print("yb=",yb)
print("ka=",ka)
print("kb=",kb)
------------------------------------------
-----------------------------------------pr6
from math import gcd
def RSA(p: int, q: int, message: int):
 n = p * q
 t = (p - 1) * (q - 1)
 for i in range(2, t):
 if gcd(i, t) == 1:
 e = i
 j = 0
 while True:
 if (j * e) % t == 1:
 d = j
 break
 j += 1
 ct = (message ** e) % n
 print(f"Encrypted message is {ct}")
 mes = (ct ** d) % n
 print(f"Decrypted message is {mes}") 
 
p=int(input("Enter value of p : "))
q=int(input("Enter value of q : "))
msg=int(input("Enter value of msg : "))
RSA(p,q,msg)
---------------------------------------------------
-------------------------------------------pr7
import hashlib

def file_check(filename):
    hash1=hashlib.md5()
    with open(filename,'rb')as open_file:
        content = open_file.read()
        hash1.update(content)
    print(hash1.hexdigest())

def pass_check(pw):
    hash1 = hashlib.md5(pw.encode('utf-8'))
    print ("Your md5 password is",hash1.hexdigest())

print("__MD5__")
print("1.File_check \n2. Password_check")
choice=int(input("Please enter your choice :"))
if(choice == 1):
    print("File Check")
    fn="hello.txt"
    file_check(fn)
elif(choice==2):
     print("Password Check")
     pw=input("Enter a password")
     pass_check(pw)
else:
    print("Wrong Choice")


hello.txt---->101001011
-----------------------------------
------------------------------pr8
import hashlib
def filecheck(filename):
    hash1=hashlib.sha1()
    with open(filename,'rb') as open_file:
        content=open_file.read()
        hash1.update(content)
    print(hash1.hexdigest)
 
def passcheck(pw):
    hash1=hashlib.sha1(pw.encode('utf-8'))
    print ("your sha1 password is",hash1.hexdigest())
print("__SHA1__")
print("1 file_check \n2. password_check")
choice=int(input("please enter your choice:"))
if(choice==1):
    print("File_check")
    fn='hello.txt'
    filecheck(fn)
elif(choice==2):
    print("Password check")
    pw=input("Enter a password")
    passcheck(pw)
else:
    print("wrong choice")

hello.txt ---> 101001011
----------------------------------------
-------------------------------------pr9
from elgamal.elgamal import Elgamal
m=bytes(input("Enter plain text : "),'utf-8')
print(m)
pb, pv = Elgamal.newkeys(128)
print(pb)
print(pv)
ct = Elgamal.encrypt(m, pb)
print("Encrypt : ",ct)
dd = Elgamal.decrypt(ct, pv)
print("Decrypt : ",dd)
print()
----------------------------------
from ecdsa import SigningKey, SECP256k1
from hashlib import sha256
prk = SigningKey.generate(curve=SECP256k1)
puk = prk.get_verifying_key()
msg = b"this msg is sign using schnorr algorithm"
msg_hash = sha256(msg).digest()
sign= prk.sign(msg_hash)
is_valid = puk.verify(sign, msg_hash)
print("msg:", msg)
print("Public Key:", puk.to_string("compressed").hex())
print("Signature:", sign.hex())
print("Signature is valid:", is_valid)
